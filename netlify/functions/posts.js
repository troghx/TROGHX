// netlify/functions/posts.js
import { neon, neonConfig } from "@neondatabase/serverless";

neonConfig.fetchConnectionCache = true;

const DB_URL =
  process.env.DATABASE_URL ||
  process.env.NETLIFY_DATABASE_URL ||
  process.env.NETLIFY_DATABASE_URL_UNPOOLED;

const sql = DB_URL ? neon(DB_URL) : null;

const json = (status, data, extraHeaders = {}) => ({
  statusCode: status,
  headers: {
    "Content-Type": "application/json; charset=utf-8",
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,POST,PUT,DELETE,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    ...extraHeaders,
  },
  body: JSON.stringify(data),
});

function getQS(event) {
  return event.queryStringParameters || {};
}
function requireBearer(event) {
  const auth = event.headers?.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "").trim();
  const envToken = process.env.AUTH_TOKEN || "";
  if (!envToken || token !== envToken) {
    return { ok: false, res: json(401, { error: "Unauthorized" }) };
  }
  return { ok: true };
}
function getIdFromPath(path) {
  const parts = String(path).split("/").filter(Boolean);
  const i = parts.lastIndexOf("posts");
  return i >= 0 ? parts[i + 1] : null;
}

async function ensureSchema() {
  // Tabla base
  await sql`CREATE TABLE IF NOT EXISTS posts (
    id              BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    title           TEXT NOT NULL,
    description     TEXT,
    image           TEXT,
    image_thumb     TEXT,             -- miniatura ligera para el grid
    preview_video   TEXT,             -- trailer en base64 opcional
    category        TEXT DEFAULT 'game',
    first_link      TEXT,             -- primer enlace detectado en la descripción
    link_ok         BOOLEAN,          -- estado cacheado del enlace
    created_at      TIMESTAMPTZ DEFAULT now()
  )`;
  await sql`CREATE INDEX IF NOT EXISTS idx_posts_cat_created ON posts (category, created_at DESC)`;
}

function cacheHeaders(seconds = 60) {
  return {
    "Cache-Control": `public, max-age=${seconds}, stale-while-revalidate=30`,
  };
}

export async function handler(event) {
  try {
    if (event.httpMethod === "OPTIONS") return json(204, {});
    if (!sql) return json(500, { error: "DB not configured" });

    await ensureSchema();

    /* ---------------- GET list ---------------- */
    if (event.httpMethod === "GET" && event.path.endsWith("/posts")) {
      const qs = getQS(event);
      const limit = Math.min(Math.max(parseInt(qs.limit || "200", 10) || 200, 1), 200);
      const lite  = qs.lite === "1";
      const category = (qs.category || "game").toLowerCase();

      if (lite) {
        const rows = await sql`
          SELECT id, title, category, image_thumb, created_at, link_ok, first_link
          FROM posts
          WHERE category = ${category}
          ORDER BY created_at DESC
          LIMIT ${limit}
        `;
        return json(200, rows, cacheHeaders(60));
      } else {
        // versión pesada (evita usarla en el grid)
        const rows = await sql`
  SELECT
    id,
    title,
    category,
    COALESCE(image_thumb, image) AS image_thumb,
    created_at,
    link_ok,
    first_link
  FROM posts
  WHERE category = ${category}
  ORDER BY created_at DESC
  LIMIT ${limit}
`;
        return json(200, rows, cacheHeaders(20));
      }
    }

    /* ---------------- GET detail / video ---------------- */
    if (event.httpMethod === "GET" && event.path.includes("/posts/")) {
      const id = getIdFromPath(event.path);
      if (!id) return json(400, { error: "missing id" });
      const qs = getQS(event);
      const onlyVideo = qs.video === "1";

      if (onlyVideo) {
        const rows = await sql`SELECT preview_video FROM posts WHERE id = ${id} LIMIT 1`;
        if (!rows.length) return json(404, { error: "not found" });
        return json(200, { previewVideo: rows[0].preview_video || null }, cacheHeaders(300));
      } else {
        const rows = await sql`
          SELECT id, title, category, image, description, created_at, link_ok, first_link
          FROM posts WHERE id = ${id} LIMIT 1
        `;
        if (!rows.length) return json(404, { error: "not found" });
        const r = rows[0];
        return json(200, {
          id: r.id,
          title: r.title,
          category: r.category,
          image: r.image,
          description: r.description,
          created_at: r.created_at,
          link_ok: r.link_ok,
          first_link: r.first_link
        }, cacheHeaders(60));
      }
    }

    /* ---------------- POST create ---------------- */
    if (event.httpMethod === "POST" && event.path.endsWith("/posts")) {
      const g = requireBearer(event);
      if (!g.ok) return g.res;
      const body = JSON.parse(event.body || "{}");

      const title        = (body.title || "").trim();
      const category     = (body.category || "game").toLowerCase();
      const image        = body.image || null;
      const image_thumb  = body.image_thumb || null;
      const description  = body.description || null;
      const previewVideo = body.previewVideo || null;
      const link_ok      = typeof body.link_ok === "boolean" ? body.link_ok : null;
      const first_link   = body.first_link || null;

      if (!title || !image || !image_thumb || !description) {
        return json(400, { error: "missing fields" });
      }

      const rows = await sql`
        INSERT INTO posts (title, category, image, image_thumb, description, preview_video, link_ok, first_link)
        VALUES (${title}, ${category}, ${image}, ${image_thumb}, ${description}, ${previewVideo}, ${link_ok}, ${first_link})
        RETURNING id
      `;
      return json(200, { id: rows[0].id });
    }

    /* ---------------- PUT update ---------------- */
    if (event.httpMethod === "PUT" && event.path.includes("/posts/")) {
      const g = requireBearer(event);
      if (!g.ok) return g.res;
      const id = getIdFromPath(event.path);
      if (!id) return json(400, { error: "missing id" });

      const body = JSON.parse(event.body || "{}");

      const sets = [];
      if ("title"        in body) sets.push(sql`title = ${ (body.title||"").trim() }`);
      if ("category"     in body) sets.push(sql`category = ${ (body.category||"game").toLowerCase() }`);
      if ("description"  in body) sets.push(sql`description = ${ body.description || null }`);
      if ("image"        in body) sets.push(sql`image = ${ body.image || null }`);
      if ("image_thumb"  in body) sets.push(sql`image_thumb = ${ body.image_thumb || null }`);
      if ("previewVideo" in body) sets.push(sql`preview_video = ${ body.previewVideo || null }`);
      if ("link_ok"      in body) sets.push(sql`link_ok = ${ typeof body.link_ok === "boolean" ? body.link_ok : null }`);
      if ("first_link"   in body) sets.push(sql`first_link = ${ body.first_link || null }`);

      if (!sets.length) return json(400, { error: "no fields to update" });

      await sql`UPDATE posts SET ${sql.join(sets, sql`, `)} WHERE id = ${id}`;
      return json(200, { ok: true });
    }

    /* ---------------- DELETE ---------------- */
    if (event.httpMethod === "DELETE" && event.path.includes("/posts/")) {
      const g = requireBearer(event);
      if (!g.ok) return g.res;
      const id = getIdFromPath(event.path);
      if (!id) return json(400, { error: "missing id" });
      await sql`DELETE FROM posts WHERE id = ${id}`;
      return json(200, { ok: true });
    }

    return json(404, { error: "Not found" });
  } catch (err) {
    console.error("[posts] error", err);
    return json(500, { error: "Internal Server Error" });
  }
}

