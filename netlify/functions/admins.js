// netlify/functions/admins.js
import { neon } from "@neondatabase/serverless";
import { json as baseJson } from "./utils.js";

const DB_URL =
  process.env.DATABASE_URL ||
  process.env.NETLIFY_DATABASE_URL ||
  process.env.NETLIFY_DATABASE_URL_UNPOOLED;

const sql = DB_URL ? neon(DB_URL) : null;
let schemaReady = false;

const json = (status, data, extra = {}) =>
  baseJson(status, data, {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "GET,POST,DELETE,OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization",
    ...extra,
  });

async function ensureSchema() {
  await sql`CREATE TABLE IF NOT EXISTS admin_keys (
    id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name         TEXT,
    key_hash     TEXT UNIQUE NOT NULL,
    created_at   TIMESTAMPTZ DEFAULT now(),
    revoked_at   TIMESTAMPTZ
  )`;
  await sql`CREATE INDEX IF NOT EXISTS idx_admin_keys_revoked ON admin_keys (revoked_at)`;
}

// helpers
function pathParts(path) { return String(path).split("/").filter(Boolean); }
function getIdFromPath(path) {
  const parts = pathParts(path);
  const idx = parts.lastIndexOf("admins");
  const id = idx >= 0 ? parts[idx + 1] : null;
  return id || null;
}
function requireBearer(event) {
  const auth = event.headers?.authorization || "";
  const token = auth.replace(/^Bearer\s+/i, "").trim();
  const envToken = process.env.AUTH_TOKEN || "";
  if (!envToken || token !== envToken) {
    return { ok: false, res: json(401, { error: "Unauthorized" }) };
  }
  return { ok: true };
}

export async function handler(event) {
  try {
    if (event.httpMethod === "OPTIONS") return json(204, {});
    if (!sql) return json(500, { error: "DB not configured" });

    if (!schemaReady) {
      await ensureSchema();
      schemaReady = true;
    }

    // POST /admins/login  => {keyHash}  -> {ok:true/false}
    if (event.httpMethod === "POST" && event.path.endsWith("/admins/login")) {
      let body = {};
      try {
        body = JSON.parse(event.body || "{}");
      } catch (_) {
        return json(400, { ok: false, error: "invalid json" });
      }
      const keyHash = (body.keyHash || "").trim();
      if (!keyHash) return json(400, { ok: false, error: "missing keyHash" });
      const rows =
        await sql`SELECT id, revoked_at FROM admin_keys WHERE key_hash = ${keyHash} LIMIT 1`;
      const ok = rows.length > 0 && rows[0].revoked_at == null;
      return json(200, { ok });
    }

    // GET /admins  (list)  -> requiere AUTH_TOKEN
    if (event.httpMethod === "GET" && event.path.endsWith("/admins")) {
      const g = requireBearer(event); if (!g.ok) return g.res;
      const rows =
        await sql`SELECT id, name, created_at, revoked_at FROM admin_keys ORDER BY created_at DESC`;
      return json(200, rows);
    }

    // POST /admins  (create)  {name, keyHash} -> {id}
    if (event.httpMethod === "POST" && event.path.endsWith("/admins")) {
      const g = requireBearer(event); if (!g.ok) return g.res;
      let body = {};
      try {
        body = JSON.parse(event.body || "{}");
      } catch (_) {
        return json(400, { error: "invalid json" });
      }
      const name = (body.name || "").trim();
      const keyHash = (body.keyHash || "").trim();
      if (!keyHash) return json(400, { error: "missing keyHash" });
      const rows =
        await sql`INSERT INTO admin_keys (name, key_hash) VALUES (${name || null}, ${keyHash})
                  ON CONFLICT (key_hash) DO NOTHING
                  RETURNING id`;
      if (!rows.length) return json(409, { error: "key already exists" });
      return json(200, { id: rows[0].id });
    }

    // DELETE /admins/:id  -> revocar (ban)
    if (event.httpMethod === "DELETE") {
      const g = requireBearer(event); if (!g.ok) return g.res;
      const id = getIdFromPath(event.path);
      if (!id || !/^\d+$/.test(String(id))) return json(400, { error: "missing id" });
      await sql`UPDATE admin_keys SET revoked_at = now() WHERE id = ${id}`;
      return json(200, { ok: true });
    }

    return json(404, { error: "Not found" });
  } catch (err) {
    console.error("[admins] error", err);
    return json(500, { error: "Internal Server Error" });
  }
}
